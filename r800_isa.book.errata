in R800_isa.book revision 1.0e

inconsistency through the whole pdf:
	"WORD" is used instead of DWORD, which is okay if you define 32 as a WORD, but sometimes the more traditional DWORD is mixed in too.
	like on page 2-10, on table 2.7, DWORD is used.
	and later in table 2.8 DWORD is used.
	and in chapter 3.
	But later chapter seems to favour using WORD, like CF_WORD and ALU_WORD instead of DWORD, like in chapter 6.


page: 9-15 (opcode is wrong)
	"CF_INST == CF_INST_EXPORT, opcode 39 (0x27)." CF_ALLOC_EXPORT_WORD1_SWIZ  CF_INST_EXPORT has value 83 and not 39.


page: 9-16 (opcode is wrong)
	"CF_INST == CF_INST_EXPORT_DONE, opcode 40 (0x28)." CF_ALLOC_EXPORT_WORD1_SWIZ  CF_INST_EXPORT_DONE has value 84 and not 40.


page: 9-24 (opcode is wrong)
	"CF_INST == CF_INST_JUMPTABLE, opcode 28 (0x1D)." CF_INST_JUMPTABLE is 29.


page: 9-37 (embarassing typo)
	"CNDNE_64
	Compares the src0 with floating-point ero"
	should be "zero"

page: 9-243 (wrong pseudo code)
	"SQRT_IEEE
	Scalar square root. Useful for normal compression.
	If (src0 == 1.0f) {
	dst = 1.0f;
	}
	Else {
	dst = ApproximateRecipSqrt(srcC);
	}"
	should be "ApproximateSqrt" and "(src0)"
	or srcC might have some (?) meaning but it's undefined
	
page: 9-214 (wrong pseudo code)
	RECIPSQRT_IEEE on page  uses "(srcC)" too instead of src0

page: 9-35 (order of the dwords is mixed up)
	MEM_RAT_CACHELESS
	order in the pdf:
	"CF_ALLOC_EXPORT_WORD1_BUF CF_ALLOC_EXPORT_WORD0_RAT"
	but both the numbering and the binary images generated from OpenCL imply the reverse.
	The ordering is consistently wrong on the figure depicting binary structure of the words too. 

	I haven't tested it, but it might be the case with page: 9-34 (MEM_RAT) and page 9-36 (MEM_RAT_COMBINED_CACHELESS)


page: 9-37 (inconsistency)
	MEM_RING* instructions contains CF_ALLOC_EXPORT_WORD1_SWIZ microcode. It has CF_INST field but it doesn't contain the CF_INST_MEM_RING* values. CF_ALLOC_EXPORT_WORD1_BUF has the CF_INST field which contains these values.


page: 9-39 (inconsistency)
	CF_ALLOC_EXPORT_WORD1_BUF has CF_INST field but it hasn't CF_INST_MEM_SCRATCH only CF_INST_MEM_WR_SCRATCH and it has a value 80 and not 36.


page: 9-131 (opcode is wrong)
	"LSHR_INT
	ALU_INST == OP2_INST_LSHR_INT, opcode 113 (0x71)"
	but according to page 10-28 (ALU_WORD1_OP2) the opcode 113 is reserved and OP2_INST_LSHR_INT is 22

  ASHR_INT and LSHR_INT shares a similar problem

page: 9-67 (opcode is wrong)
	CNDE
	opcode 24 is written here
	but ALU_WORD1_OP3 defines OP3_INST_MULADD_IEEE to be 24
	
	ALU_WORD1_OP3 defines these opcodes at page 10-34:
		25 OP3_INST_CNDE
		26 OP3_INST_CNDGT
		27 OP3_INST_CNDGE
	
	but at page 9-71 the opcode of CNDGT is 25
	but at page 9-69 the opcode of CNDGE is 26
	
	CND.._INT seems okay
	
	I haven't tested which one is okay, but the ALU_WORD1_OP3 definition seems to be the correct one.
	
page: 9-68 (opcode enum name is wrong)
	CNDE_INT
	"ALU_INST == OP3_INST_CMOVE_INT"
	
	there is no OP3_INST_CMOVE_INT enum defined at all, instead there is a  OP3_INST_CNDE_INT with the same opcode numeric value
	
	instructions: CNDE, CNDGE, CNDGE_INT, CNDGT, CNDGT_INT share the same problem 
	
	nonexistent CMOVE is mentioned at:
		page 4-21 table 4.4
		glossary-7 (written like "CMOV")


page: 10-11 (misspelling)
	"KCACHE_BANK_IDEX_MODE1 [7:6]" Missing N letter after letter I.


page: 10-11 (misspelling)
	"1 CF_KCACHE_LOCK_1: lock cache lines [bank][addr]."
	"2 CF_KCACHE_LOCK_1: lock cache lines [bank][addr] and [bank][addr+1]."
	Same enum name. The first one should be CF_KCACHE_LOCK_0.


page: 10-13 (misspelling)
	Same as at page 10-11.
	At field KCACHE_MODE3:
	"1 CF_KCACHE_LOCK_1: lock cache lines [bank][addr]."
	"2 CF_KCACHE_LOCK_1: lock cache lines [bank][addr] and [bank][addr+1]."
	Same enum name. The first one should be CF_KCACHE_LOCK_0.


page: 10-27 (inconsistency)
	definition of ALU_WORD1_OP2
	"Gaps in opcode values are not marked in the list below." -> They are sometimes marked but why then?
	on page 10-29: "129 to 95 are for transcendental units only." only 129 is a valid opcode the other are reserved, it should have been: 129 to 156" or "129 to 159" (like it was noted on page 10-27)

page 10-38 (minor typo)
	"ALU_WORD0_LDS_iDX_OP" should be ALU_WORD0_LDS_IDX_OP

page 10-39 (copy paste)
	ALU_WORD1_LDS_IDX_OP contains SRC1_SEL [21:13] field. These bits are used by other fields.

page 10-39 (copy paste)
	ALU_WORD1_LDS_IDX_OP contains SRC0_SEL [8:0] field. This should be SRC2_SEL.0

page 10-40: (inconsistency)
	ALU_WORD1_LDS_IDX_OP
	in ALU_INST field description
		"[17:13] enum(5)
		[16:0] Reserved.
		17 OP3_INST_LDS_IDX_OP: This opcodes implies ALU_WORD*_LDS_IDX_OP encoding.
		[31:18] Reserved."
	bits 16:0 and 31:18 are not reserved, they are used very much in ALU_WORD1_LDS_IDX_OP

page 10-47: (missing enum)
	in VTX_WORD1_GPR, DATA_FORMAT field
	instead of explaining the possible values I found this:
	"See list for DATA_FORMAT [27:22] in VTX_WORD1_GPR, page 10-47, and VTX_WORD1_SEM, page 10-49."
	Which is a self reference. It also the same on page 10-49.
	I haven't found any other mention of the DATA_FORMAT. If I want to probram a vertex fetch, then I have to reverse engineer.
	
